"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useClock = exports.useMousePosition = exports.useFindElementCenter = exports.useVisiblePose = exports.usePose = exports.useHovered = exports.useCanHover = void 0;
const react_1 = require("react");
const useCanHover = () => {
    // assume that if device is smaller than 500 there's no hover, but actually check it on the first touch event
    const [canHover, setCanHover] = react_1.useState(window.innerWidth > 500);
    react_1.useEffect(() => {
        // mobile devices also emit a "mousemove" on every touch (#theplatform<3), but desktop devices don't emit "touchstart"
        const eventName = 'touchstart';
        window.addEventListener(eventName, function onFirstTouch() {
            setCanHover(false);
            window.removeEventListener(eventName, onFirstTouch, false);
        }, false);
    }, []);
    return canHover;
};
exports.useCanHover = useCanHover;
const useHovered = () => {
    const [hovering, setHovering] = react_1.useState(false);
    const canHover = exports.useCanHover();
    return {
        value: hovering,
        setValue: setHovering,
        bind: canHover
            ? {
                onMouseOver: () => setHovering(true),
                onMouseLeave: () => setHovering(false),
            }
            : {
                onClick: () => setHovering((h) => !h),
            },
    };
};
exports.useHovered = useHovered;
const usePose = (initial, poses = {}) => {
    const [pose, setPose] = react_1.useState(initial);
    return { pose, setPose, poses };
};
exports.usePose = usePose;
const useVisiblePose = (initial) => {
    const VISIBLE = 'visible';
    const HIDDEN = 'hidden';
    const _a = exports.usePose(initial ? VISIBLE : HIDDEN, [HIDDEN, VISIBLE]), { setPose, pose } = _a, rest = __rest(_a, ["setPose", "pose"]);
    return [pose, (v) => setPose(v ? VISIBLE : HIDDEN), rest];
};
exports.useVisiblePose = useVisiblePose;
const useFindElementCenter = (elementRef) => {
    const [windowSize, setWindowSize] = react_1.useState();
    react_1.useEffect(() => {
        if (elementRef.current) {
            const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = elementRef.current;
            setWindowSize({
                x: window.innerWidth / 2 - offsetWidth / 2 - offsetLeft,
                y: window.innerHeight / 2 - offsetHeight / 2 - offsetTop,
            });
        }
    }, [elementRef]);
    return windowSize;
};
exports.useFindElementCenter = useFindElementCenter;
const useMousePosition = (shouldTrack) => {
    const [mousePosition, setMousePosition] = react_1.useState({ x: 0, y: 0 });
    const canHover = exports.useCanHover();
    react_1.useEffect(() => {
        if (canHover && shouldTrack) {
            const handler = ({ clientX, clientY }) => {
                setMousePosition({
                    x: clientX,
                    y: clientY,
                });
            };
            window.document.addEventListener('mousemove', handler);
            return () => window.document.removeEventListener('mousemove', handler);
        }
        return () => { };
    }, [canHover, shouldTrack]);
    return canHover ? mousePosition : {};
};
exports.useMousePosition = useMousePosition;
const useClock = (timeFormattingFunction = (date) => date.toLocaleDateString()) => {
    const getCurrentTime = react_1.useCallback(() => timeFormattingFunction(new Date()), [timeFormattingFunction]);
    const [time, setTime] = react_1.useState(getCurrentTime());
    react_1.useEffect(() => {
        const t = setInterval(() => setTime(getCurrentTime()), 1000);
        return () => clearInterval(t);
    }, [getCurrentTime]);
    return time;
};
exports.useClock = useClock;
//# sourceMappingURL=useSizzyHooks.js.map